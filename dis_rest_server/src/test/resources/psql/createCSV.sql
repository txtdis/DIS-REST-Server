begin;

\copy (select -id,  'SYSGEN' as createdby, time_stamp as createdon, name, tier_id as tier from item_family  where id <> 0 ) to '/Users/txtDIS/db-convert/data/item_family.txt' (delimiter '|');

\copy (select row_number() over(order by time_stamp) as id, 'SYSGEN' as createdby, time_stamp as createdon, -child_id as family_id, -parent_id as parent_id from item_tree where parent_id < 0 and child_id < 0) to '/Users/txtDIS/db-convert/data/item_tree.txt' (delimiter '|');

delete from item_tree where child_id = 696 and parent_id = -244;
delete from item_tree where child_id = 675 and parent_id = -23;
delete from item_tree where child_id = 847 and parent_id = -283;
delete from item_tree where child_id = 845 and parent_id = -237;

\copy (select h.id, case when h.user_id = 'txtdis' or h.user_id = 'postgres' then 'SYSGEN' else upper(h.user_id) end as createdby, h.time_stamp as createdon, case when short_id is null then ('DISABLED ' || h.id) else short_id end as name, null as deactivatedby, null as deactivatedon, name as description, not_discounted as notdiscounted, (type_id - 1) as type, unspsc_id as vendorid, -parent_id as familyid from item_header h left join item_tree t on h.id = t.child_id) to '/Users/txtDIS/db-convert/data/item.txt' (delimiter '|');

\copy (select row_number() over(order by item_id, uom) as id, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as createdby, time_stamp as createdon, buy as ispurchased, qty, report as isreported, sell as issold, uom, item_id from qty_per q inner join item_header as i on q.item_id = i.id) to '/Users/txtDIS/db-convert/data/qty_per_uom.txt' (delimiter '|');

delete from price where price is null;
update price set user_id='kimberly' where item_id = 518;
update price set user_id='sheryl' where item_id = 115 and start_date = '2014-04-06';
update price set user_id='sheryl' where item_id = 302 and start_date = '2014-07-01';
update price set user_id='sheryl' where item_id = 647 and start_date = '2014-01-22';

\copy (select row_number() over(order by time_stamp, item_id, tier_id) as id, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as createdby, time_stamp as createdon, price as pricevalue, start_date as startdate, case when tier_id = 0 then 5 when tier_id = 1 then null else 9 end as channellimit_id, case when tier_id = 0 then 1 when tier_id = 1 then 2 else 3 end as type_id, item_id from price where tier_id in (0, 1, 3)) to '/Users/txtDIS/db-convert/data/pricing.txt' (delimiter '|');

\copy (select row_number() over(order by time_stamp) as id, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as createdby, time_stamp as createdon, per_qty as cutoff, less as discount, start_date as startdate, 0 as type, uom, null as channellimit_id, item_id from volume_discount) to '/Users/txtDIS/db-convert/data/volume_discount.txt' (delimiter '|');

update customer_header set name = 'DUPLICATE OF 227' where id = 149;
update customer_header set name = 'DUPLICATE OF 462' where id = 71;
update customer_header set name = 'DUPLICATE OF 278' where id = 512;
update customer_header set name = 'DUPLICATE OF 331' where id = 577;
update customer_header set name = 'DUPLICATE OF 843' where id = 839;
update customer_header set name = 'DUPLICATE OF 167' where id = 847;
update customer_header set name = 'DUPLICATE OF 677' where id = 930;
update customer_header set name = 'LITAS STORE' where id = 377;
update customer_header set name = 'ROSE SFDM' where id = 691;
update customer_header set name = 'ROLAND SHORTAGE' where id = 816;
update customer_header set user_id = 'postgres' where id in (432, 532, 530);
update address set district = 18 where district = 1 and street like '%PABAHAY%';
update address set district = 40 where district = 1 and street like '%BRIGHT%';
update address set district = 35 where customer_id = 712;
update address set district = 36 where customer_id = 716;
update address set district = 34 where customer_id = 756;
delete from customer_header where id = 827;
delete from customer_header where name is null;

delete from discount where customer_id = 863;
delete from credit where customer_id = 863;
delete from account where customer_id = 863;
delete from customer_header where id = 863;

delete from discount where customer_id = 1063;
delete from credit where customer_id = 1063;
delete from account where customer_id = 1063;
delete from customer_header where id = 1063;

alter table phone_number alter number type text;

\copy (select distinct case when ch.id = 0 then 574 else ch.id end as id, case when ch.user_id in ('txtdis', 'postgres') then 'SYSGEN' else upper(ch.user_id) end as createdby, ch.time_stamp as createdon, case when ch.name in ( 'CUEVAS BAKERY', 'CENON', 'EMMA STORE', 'JENNY STORE', 'CITA STORE', 'AIDA STORE', 'JOSEPHINE STORE', 'CORA STORE', 'SUSAN', 'JOSIE', 'LIZA STORE', 'GINA STORE', 'LILY STORE', 'MHAIKEL STORE', 'HELEN STORE', 'LORNA STORE' , 'MILA STORE', 'LEMON HIPOLITO', 'ROSE STORE', 'LOURDES STORE', 'CARMEN', 'CUEVAS BREAD', 'JASCON', 'SACOPLA', 'JERRY', 'TINDAHAN SA KANTO', 'ZENY STORE', 'MALOU STORE', 'GRACE STORE', 'SALLY STORE', 'MICHELLE', 'FLOR', 'DINO', 'ROSE', 'MINA', 'RUDY STORE', 'JANETH', 'JOY', 'LILIBETH STORE', 'VICKY STORE', 'MHAIRA', 'CLARISE', 'JULIAN', 'ALONA', 'LINDA STORE') then ch.name || ' (' || (case when brgy.name is null then 'UNKNOWN' else brgy.name end) || ') '  else ch.name end as name, null as deactivated_by, null as deactivated_on, cd.name as contactname, cd.surname as credit_contactsurname, designation as contacttitle, case when number is not null then '+63' || number else number end as mobile, street, case when ch.type_id = 10 then (case when ch.id in (559, 560) then 0 else 3 end) when ch.type_id = 12 then 2 else 1 end as type, 2 as visit_frequency, case when ch.type_id = 8 then 2 else null end as alternate_pricing_type_id, case when district is null and city = 2 then 27 when district is null then 34 else district end as barangay_id, case when ch.type_id in(1, 9, 15) then 5 when ch.type_id in (0, 3, 10, 11, 12, 13, 14, 16) then 7 when ch.type_id = 7 then 8 when ch.type_id = 8 then 9 else ch.type_id end as channel_id, case when city is null then 33 else city end as city_id, branch_of as parent_id, case when ch.type_id = 9 or ch.type_id = 15 then 1 when ch.type_id in (1, 10, 11, 13, 14) then null when ch.type_id = 8 then 3 else 2 end as primary_pricing_type_id, case when province is null then 1 else province end as province_id from customer_header as ch left join address as ad on ch.id = ad.customer_id left join area as brgy on ad.district = brgy.id left join credit as cr on ch.id = cr.customer_id left join contact_detail as cd on ch.id = cd.customer_id and cd.customer_id <> 0 left join phone_number as ph on cd.id = ph.contact_id) to '/Users/txtDIS/db-convert/data/customer.txt' (delimiter '|');

\copy (select row_number() over(order by customer_id, start_date desc) as id, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as createdby, time_stamp as createdon, case when credit_limit is null and (term > 0) then 1000 when credit_limit = 0 then null else credit_limit end as creditlimit, case when grace_period = 0 then null else grace_period end as graceperiodindays, start_date as startdate, case when term = 0 then null else term end as termindays, customer_id from credit) to '/Users/txtDIS/db-convert/data/credit_detail.txt' (delimiter '|');

\copy (select row_number() over(order by time_stamp, customer_id, family_id, level) as id, user_id as createdby, time_stamp as createdon, level, per_cent as percent, start_date as startdate, -family_id as familylimit_id, customer_id from ((select time_stamp, 1 as level, case when level_1 = 0 then null else level_1 end as per_cent, start_date, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as user_id, family_id, customer_id from discount) union (select time_stamp, 2 as level, level_2 as per_cent, start_date, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as user_id, family_id, customer_id from discount where level_2 > 0)) as u) to '/Users/txtDIS/db-convert/data/customer_discount.txt' (delimiter '|');

\copy (select id + 1 as id, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as createdby, time_stamp as createdon, name from route order by id) to '/Users/txtDIS/db-convert/data/route.txt' (delimiter '|');

\copy (select row_number() over (order by time_stamp) as id, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as createdby, time_stamp as createdon, start_date, route_id + 1 as route_id, customer_id from account where route_id <> -1) to '/Users/txtDIS/db-convert/data/routing.txt' (delimiter '|');

\copy (select distinct on (sh.sales_id) sh.sales_id as id, case when sh.user_id = 'txtdis' or sh.user_id = 'postgres' or sh.user_id = 'vier' or sh.sales_id = 10264 or sh.sales_id = 15950 or sh.sales_id = 13800 or sh.user_id = '7' then 'SYSGEN' else upper(sh.user_id) end as createdby, sh.time_stamp as createdon, sales_date as orderdate, null as remarks, case when spo.user_id = 'txtdis' or spo.user_id = 'postgres' or spo.user_id = 'vier'  then 'SYSGEN' else upper(spo.user_id) end as printedby, spo.time_stamp as printed_on, case when sh.customer_id = 0 or sh.customer_id is null then 574 else sh.customer_id end as customer_id, null as picklist_id from sales_header as sh left join sales_print_out as spo on sh.sales_id = spo.sales_id left join account as acc on sh.customer_id = acc.customer_id and acc.start_date <= sh.sales_date where sh.sales_date >= '2014-01-01') to '/Users/txtDIS/db-convert/data/booking.txt' (delimiter '|');

\copy (with payment as (select d.order_id, d.series, sum(d.payment) as payment from remit_detail as d inner join remit_header as h on h.remit_id = d.remit_id where h.remit_date <= current_date group by order_id, series) select row_number() over(order by created_on) as id, * from ((select distinct on (sh.invoice_id, sh.series) case when sh.user_id = 'txtdis' or sh.user_id = 'postgres' or sh.user_id = 'vier' then 'SYSGEN' when sh.user_id = 'jessa' or sh.user_id = 'donna' then 'GLAZEL' else upper(sh.user_id) end as created_by, sh.time_stamp as created_on, case when invoice_date is null then cast(sh.time_stamp as date) else invoice_date end as order_date, case when actual is null or actual = 0 then 'CANCELLED' else null end as remarks, case when actual is null then 0 else actual end as actual, case when actual is null or actual = 0 or actual - payment <= 0 then true else false end as is_fully_paid, sh.invoice_id as id_no, null as prefix, sh.series as suffix, case when sh.customer_id = 0 or sh.customer_id is null then 574 else sh.customer_id end as customer_id, case when ref_id in (select distinct ref_id from invoice_header where invoice_date >= '2014-01-01' and ref_id not in (select sales_id from sales_header where sales_date >= '2014-01-01')) then null else ref_id end as booking_id from invoice_header as sh left join account as acc on sh.customer_id = acc.customer_id and acc.start_date <= sh.invoice_date left join payment as p on -sh.invoice_id = p.order_id and sh.series = p.series) union (select distinct on (sh.delivery_id) case when sh.user_id = 'txtdis' or sh.user_id = 'postgres' or sh.user_id = 'vier' then 'SYSGEN' when sh.user_id = 'jessa' or sh.user_id = 'donna' then 'GLAZEL' else upper(sh.user_id) end as createdby, sh.time_stamp as createdon, case when delivery_date is null then cast(sh.time_stamp as date) else delivery_date end as order_date, case when actual is null or actual = 0 then 'CANCELLED' else null end as remarks, case when actual is null then 0 else actual end as actual, case when actual is null or actual = 0 or actual - payment <= 0 then true else false end as is_fully_paid, -sh.delivery_id as id_no, null as prefix, null as suffix, case when sh.customer_id = 0 or sh.customer_id is null then 574 else sh.customer_id end as customer_id, case when ref_id in (select distinct ref_id from delivery_header where delivery_date >= '2014-01-01' and ref_id not in (select sales_id from sales_header where sales_date >= '2014-01-01')) then null else ref_id end as booking_id from delivery_header as sh left join account as acc on sh.customer_id = acc.customer_id and acc.start_date <= sh.delivery_date left join payment as p on sh.delivery_id = p.order_id)) as u where order_date >= '2014-01-01' order by booking_id ) to '/Users/txtDIS/db-convert/data/invoicing.txt' (delimiter '|');    

\copy (with detail as (select qty, uom, quality, price, item_id, id_no, series, booking_id, time_stamp from ((select distinct on (sh.delivery_id, sh.item_id) sh.qty, sh.uom, case when sh.item_id < 0 then 1 else 0 end as quality, ((case when abs(sh.item_id) = 328 or abs(sh.item_id) = 483 then (last_value(pd.price) over(partition by sh.item_id order by pd.start_date asc) * 3 - 5) / 3 else (case when sh.uom = 5 then 1 else (case when (last_value(p.price) over(partition by sh.item_id order by p.start_date asc)) is null then (case when pd.price is null then 0 else last_value(pd.price) over(partition by sh.item_id order by pd.start_date asc) end) else last_value(p.price) over(partition by sh.item_id order by p.start_date asc) end) end) end) - (case when (sh.item_id = 328 or sh.item_id = 483) and sh.qty > 3 then 5/3 else 0 end)) * qp.qty as price, abs(sh.item_id) as item_id,-sh.delivery_id as id_no, cast (null as text) as series, (case when s.ref_id < 7550 then cast (null as int) else s.ref_id end) as booking_id, s.time_stamp from delivery_detail as sh inner join delivery_header as s on sh.delivery_id = s.delivery_id inner join qty_per as qp on abs(sh.item_id) = qp.item_id and sh.uom = qp.uom inner join customer_header as c on c.id = s.customer_id inner join channel_price_tier as cpt on c.type_id = cpt.channel_id left join price as p on cpt.tier_id = p.tier_id and p.start_date <= s.delivery_date and p.item_id = abs(sh.item_id) left join price as pd on pd.tier_id = 1 and pd.start_date <= s.delivery_date and pd.item_id = abs(sh.item_id) where s.delivery_date >= '2014-01-01') union (select distinct on (sh.invoice_id, sh.item_id) sh.qty, sh.uom, case when sh.item_id < 0 then 1 else 0 end as quality, ((case when abs(	sh.item_id) = 328 or abs(sh.item_id) = 483 then (last_value(pd.price) over(partition by sh.item_id order by pd.start_date asc) * 3 - 5) / 3 else (case when sh.uom = 5 then 1 else (case when (last_value(p.price) over(partition by sh.item_id order by p.start_date asc)) is null then (case when pd.price is null then 0 else last_value(pd.price) over(partition by sh.item_id order by pd.start_date asc) end) else last_value(p.price) over(partition by sh.item_id order by p.start_date asc) end) end) end) - (case when (sh.item_id = 328 or sh.item_id = 483) and sh.qty > 3 then 5/3 else 0 end)) * qp.qty as price, abs(sh.item_id) as item_id, sh.invoice_id as id_no, sh.series as series, (case when s.ref_id < 7550 then cast (null as int) else s.ref_id end) as booking_id, s.time_stamp from invoice_detail as sh inner join invoice_header as s on sh.invoice_id = s.invoice_id inner join qty_per as qp on abs(sh.item_id) = qp.item_id and sh.uom = qp.uom inner join customer_header as c on c.id = s.customer_id inner join channel_price_tier as cpt on c.type_id = cpt.channel_id left join price as p on cpt.tier_id = p.tier_id and p.start_date <= s.invoice_date and p.item_id = abs(sh.item_id) left join price as pd on pd.tier_id = 1 and pd.start_date <= s.invoice_date and pd.item_id = abs(sh.item_id) where s.invoice_date >= '2014-01-01')) as u), header as (select row_number() over(order by created_on) as invoice_id, * from ((select time_stamp as created_on, invoice_id as id_no, series from invoice_header where invoice_date >= '2014-01-01') union (select time_stamp as created_on, -sh.delivery_id as id_no, cast(null as text) as series from delivery_header as sh where delivery_date >= '2014-01-01')) as u), billing as (select qty, uom, quality, price, item_id, invoice_id, booking_id, time_stamp from detail as d inner join header as h on d.id_no = h.id_no and d.series = h.series), booking as (select distinct on (sh.sales_id, sh.item_id) sh.qty, sh.uom, case when sh.item_id < 0 then 1 else 0 end as quality, ((case when abs(sh.item_id) = 328 or abs(sh.item_id) = 483 then (last_value(pd.price) over(partition by sh.item_id order by pd.start_date asc) * 3 - 5) / 3 else (case when sh.uom = 5 then 1 else (case when (last_value(p.price) over(partition by sh.item_id order by p.start_date asc)) is null then (case when pd.price is null then 0 else last_value(pd.price) over(partition by sh.item_id order by pd.start_date asc) end) else last_value(p.price) over(partition by sh.item_id order by p.start_date asc) end) end) end) - (case when (sh.item_id = 328 or sh.item_id = 483) and sh.qty > 3 then 5/3 else 0 end)) * qp.qty as price, abs(sh.item_id) as item_id, null as receiving_id, null as purchasing_id, cast (null as int) as invoice_id, s.sales_id as booking_id, s.time_stamp from sales_detail as sh inner join sales_header as s on sh.sales_id = s.sales_id inner join qty_per as qp on abs(sh.item_id) = qp.item_id and sh.uom = qp.uom inner join customer_header as c on c.id = s.customer_id inner join channel_price_tier as cpt on c.type_id = cpt.channel_id left join price as p on cpt.tier_id = p.tier_id and p.start_date <= s.sales_date and p.item_id = abs(sh.item_id) left join price as pd on pd.tier_id = 1 and pd.start_date <= s.sales_date and pd.item_id = abs(sh.item_id) where s.sales_date >= '2014-01-01'), book_n_bill as (select case when u.qty is null then b.qty else u.qty end as qty, case when u.uom is null then b.uom else u.uom end as uom, case when u.quality is null then b.quality else u.quality end as quality, case when u.price is null then b.price else u.price end as price, case when u.item_id is null then b.item_id else u.item_id end as item_id,case when u.invoice_id is null then b.invoice_id else u.invoice_id end as invoice_id, case when u.booking_id is null then b.booking_id else u.booking_id end as booking_id, case when b.time_stamp is null then u.time_stamp else b.time_stamp end as time_stamp from booking as b full outer join billing as u on b.item_id = u.item_id and b.qty = u.qty and b.uom = u.uom and b.quality = u.quality and u.booking_id = b.booking_id) select row_number() over (order by time_stamp asc) as id, round(qty, 4) as qty, uom, quality, round(price, 2) as price, item_id, null as receiving_id, null as purchasing_id, invoice_id, case when booking_id = 0 then null else booking_id end as booking_id from book_n_bill where qty > 0) to '/Users/txtDIS/db-convert/data/booking_detail.txt' (delimiter '|');

update discount set level_1 = 2 where customer_id = 7 and family_id=-1 and start_date = '2014-11-16';
\copy (WITH RECURSIVE parent_child (child_id, parent_id) AS (SELECT it.child_id, it.parent_id FROM item_tree AS it UNION ALL SELECT parent_child.child_id, it.parent_id FROM item_tree it JOIN parent_child ON it.child_id = parent_child.parent_id), family as (select distinct sh.sales_id, last_value(pc.parent_id) over (partition by child_id order by parent_id asc) as family_id from sales_detail as sd inner join sales_header as sh on sd.sales_id = sh.sales_id inner join parent_child as pc on sd.item_id = pc.child_id inner join discount as d on d.customer_id = sh.customer_id and d.family_id = pc.parent_id where sd.line_id = 1), customer_discount as (select row_number() over(order by time_stamp, customer_id, family_id, level) as discount_id, level, start_date, family_id, customer_id from ((select time_stamp, 1 as level, case when level_1 = 0 then null else level_1 end as per_cent, start_date, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as user_id, family_id, customer_id from discount) union (select time_stamp, 2 as level, level_2 as per_cent, start_date, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as user_id, family_id, customer_id from discount where level_2 > 0)) as u), sales_discount as (select distinct on (s.sales_id) s.sales_id as booking_id, d.customer_id, f.family_id, first_value(d.start_date) over(partition by s.sales_id, d.customer_id, d.family_id order by d.start_date desc) as start_date from sales_header as s inner join family as f on s.sales_id = f.sales_id inner join discount as d on s.customer_id = d.customer_id and f.family_id = d.family_id and d.start_date <= s.sales_date where s.sales_date >= '2014-01-01') select s.booking_id, cd.discount_id from sales_discount as s inner join customer_discount as cd on s.customer_id = cd.customer_id and s.family_id = cd.family_id and cd.start_date = s.start_date order by s.booking_id, cd.discount_id) to '/Users/txtDIS/db-convert/data/booking_discount.txt' (delimiter '|');

\copy (WITH RECURSIVE parent_child (child_id, parent_id) AS (SELECT it.child_id, it.parent_id FROM item_tree AS it UNION ALL SELECT parent_child.child_id, it.parent_id FROM item_tree it JOIN parent_child ON it.child_id = parent_child.parent_id), billing as (select row_number() over(order by created_on) as id, * from ((select distinct on (sh.invoice_id, sh.series) sh.time_stamp as created_on, sh.invoice_id as id_no, sh.series as suffix, customer_id, invoice_date as order_date from invoice_header as sh where sh.invoice_date >= '2014-01-01') union (select distinct on (sh.delivery_id) sh.time_stamp as created_on, -sh.delivery_id as id_no, cast(null as text) as suffix, customer_id, delivery_date as order_date from delivery_header as sh where delivery_date >= '2014-01-01')) as u), family as (( select distinct on (sh.invoice_id, sh.series) sh.invoice_id as id_no, sh.series as suffix, last_value(pc.parent_id) over (partition by child_id order by parent_id asc) as family_id from invoice_detail as sd inner join invoice_header as sh on sd.invoice_id = sh.invoice_id and sd.series = sh.series inner join parent_child as pc on sd.item_id = pc.child_id inner join discount as d on d.customer_id = sh.customer_id and d.family_id = pc.parent_id where sd.line_id = 1) union ( select distinct on (sh.delivery_id) -sh.delivery_id as id_no, null as suffix, last_value(pc.parent_id) over (partition by child_id order by parent_id asc) as family_id from delivery_detail as sd inner join delivery_header as sh on sd.delivery_id = sh.delivery_id inner join parent_child as pc on sd.item_id = pc.child_id inner join discount as d on d.customer_id = sh.customer_id and d.family_id = pc.parent_id where sd.line_id = 1)), customer_discount as (select row_number() over(order by time_stamp, customer_id, family_id, level) as discount_id, level, start_date, family_id, customer_id from ((select time_stamp, 1 as level, case when level_1 = 0 then null else level_1 end as per_cent, start_date, family_id, customer_id from discount) union (select time_stamp, 2 as level, level_2 as per_cent, start_date, family_id, customer_id from discount where level_2 > 0)) as u), invoice_discount as (select distinct on (s.id) s.id, d.customer_id, f.family_id, last_value(d.start_date) over(partition by s.id, d.customer_id, d.family_id order by d.start_date asc) as start_date from billing as s inner join family as f on s.id_no = f.id_no and f.suffix = s.suffix inner join discount as d on s.customer_id = d.customer_id and f.family_id = d.family_id and d.start_date <= s.order_date) select s.id, cd.discount_id from invoice_discount as s inner join customer_discount as cd on s.customer_id = cd.customer_id and s.family_id = cd.family_id and cd.start_date = s.start_date order by s.id, cd.discount_id) to '/Users/txtDIS/db-convert/data/invoicing_discount.txt' (delimiter '|');

\copy (with tso as (select distinct on (rd.order_id) rd.order_id as remit_id, case when rh.bank_id = 559 then upper(rh.user_id) else cast(null as text) end as received_by, case when rh.bank_id = 559 then (rh.remit_date + rh.remit_time) else cast(null as timestamp) end as received_on,ch.name as deposit_bank, rh.remit_date as deposit_date, rh.remit_time as deposit_time from remit_detail as rd inner join remit_header as rh on rd.remit_id = rh.remit_id and rd.series = 'R' and rh.remit_date >= '2014-01-01' inner join customer_header as ch on rh.bank_id = ch.id) select distinct on (rh.remit_id) rh.remit_id as id, upper(rh.user_id) as createdby, rh.time_stamp as createdon, rh.ref_id as check_id, case when (rh.remit_time = '00:00:00' and ch.id <> 559) or ch.id = 560 then tso.deposit_date else rh.remit_date end as deposit_date, case when (rh.remit_time = '00:00:00' and ch.id <> 559) or ch.id = 560 then tso.deposit_time else rh.remit_time end as deposit_time, case when (rh.remit_time = '00:00:00' and ch.id <> 559) or ch.id = 560 then tso.deposit_bank else ch.name end as deposit_bank, case when rh.remit_time <> '00:00:00' or ch.id = 559 then cast(null as text) else ch.name end as drawee_bank, remit_date as due_date, case when ch.id = 559 then upper(rh.user_id) else tso.received_by end as received_by, case when ch.id = 559 then (rh.remit_date + rh.remit_time) else tso.received_on end as received_on, case when rh.remit_time <> '00:00:00' or ch.id = 559 then 'CASH' else (case when rd.order_id < 0 then chd.name else chi.name end) end as payor, cast(null as text) as remarks, rh.total as value from remit_header as rh inner join remit_detail as rd on rd.remit_id = rh.remit_id and rd.line_id = 1 left join customer_header as ch on rh.bank_id = ch.id left join delivery_header as dh on dh.delivery_id = -rd.order_id left join invoice_header as ih on ih.invoice_id = rd.order_id left join customer_header as chd on dh.customer_id = chd.id left join customer_header as chi on ih.customer_id = chi.id left join tso on tso.remit_id = rh.remit_id where remit_date >= '2014-01-01' and rd.series <> 'R') to '/Users/txtDIS/db-convert/data/remittance.txt' (delimiter '|');

--\copy (with u as (select rd.remit_id, rd.order_id, rd.series, sum(case when rd.payment is null then 0 else rd.payment end) over (partition by rd.order_id, rd.series order by rh.remit_id) - last_value(case when rd.payment is null then 0 else rd.payment end) over (partition by rd.order_id, rd.series order by rh.remit_id) as payment from remit_detail as rd inner join remit_header as rh on rd.remit_id = rh.remit_id ), o as (select invoice_id as order_id, series, invoice_date as order_date, customer_id, actual from invoice_header union select -delivery_id as order_id, ' ' as series, delivery_date as order_date, customer_id, actual from delivery_header) select distinct row_number() over(order by rd.remit_id, line_id) as id, time_stamp as createdon, case when actual is null then 0 else actual end - u.payment as unpaid_value, case when user_id = 'txtdis' or user_id = 'postgres' then 'SYSGEN' else upper(user_id) end as  createdby, case when rd.series = 'A' then rd.order_id + 1000000 when rd.series = 'B' then rd.order_id + 2000000 else rd.order_id end as order_id, rd.remit_id as remittance_id, case when rd.payment is null then 0 else rd.payment end as value from remit_detail as rd inner join remit_header as rh on rd.remit_id = rh.remit_id inner join o on rd.order_id = o.order_id and rd.series = o.series left join u on rd.remit_id = u.remit_id and rd.order_id = u.order_id and rd.series = u.series) to '/Users/txtDIS/db-convert/data/remittance_detail.txt' (delimiter '|');

end;
--\i '/Users/txtDIS/db-convert/sql/createCSV.sql';